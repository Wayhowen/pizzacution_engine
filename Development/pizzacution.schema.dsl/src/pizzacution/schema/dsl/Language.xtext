// automatically generated by Xtext
grammar pizzacution.schema.dsl.Language with org.eclipse.xtext.common.Terminals

import "http://www.example.org/schema" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

PizzaPlace: "We" "are" name=ID "," "and" "we" "are" "located" "at" address=STRING "."
	"We" "offer" "following" "sizes:" sizesAvailable+=SizeInfo ("," sizesAvailable+=SizeInfo)* "."
	"We" "have" "following" "toppings:" toppingsAvailable+=Topping ("," toppingsAvailable+=Topping)* "."
	"We" "offer" "the" "following" "pizzas:" pizzasAvailable+=Pizza ("," pizzasAvailable+=Pizza)* "."
;

SizeInfo returns Size: name=ID "that" "serves" serves=INT "people" "and" "multiplies" "the" "price" "by" priceMultiplier=FLOAT;

Pizza returns Pizza: name=STRING "pizza"
	"in" "sizes" sizeReference+=SizeReference ("," sizeReference+=SizeReference)*
	"on" dough=DoughTypes "dough"
	"with" sauce=Sauces "sauce"
	"and" toppings+=[Topping] ("," toppings+=[Topping])* "toppings"
;

SizeReference: size=[Size];

Topping returns Topping: name=ID "which" "have" 
		calories=INT "calories" ","
		carbohydrates=FLOAT "carbs" "," 
		proteins=FLOAT "proteins" ","
		fat=FLOAT "fat" "and"
		"belongs" "to" foodGroup=FoodGroup "food" "group"
		"and" "costs" price=FLOAT
;

enum Sauces returns Sauces:
				BBQ = 'BBQ' | Tomato = 'Tomato' | Garlic = 'Garlic';

enum DoughTypes returns DoughTypes:
				NewHavenStyle = 'New Haven Style' | StLouisStyle = 'St. Louis Style' | Neapolitan = 'Neapolitan' | NewYorkStyle = 'New York Style';

enum FoodGroup returns FoodGroup:
				vegetables = 'vegetables' | meats = 'meats' | cheese = 'cheese';
// Notes:
// 1. Maybe we could make a central storage of dough types and sauces and so on, to which pizza place could add?
// Then we could easily extend the enums 
// 2. How do we generate the pizza in a couple of different sizes? Like let's say I declred a pizza that is "in all sizes" and then 
// multiply that somehow 

// POSSIBLE IMPROVEMENTS:
// 1. add amount of toppings back to the model (but think about it)
// 2. move toppings to an outer storage, maybe with its own file extension? 
//but let it be a storage from which we take
// 3. think about how we can derive vegan, vegetarian and haslactose from food groups, 
// maybe food group should be separate model instead
// 4. add differentiation for when we have 1 item and many (s ending for words)
// 5.


FLOAT returns ecore::EFloat: INT '.' INT;