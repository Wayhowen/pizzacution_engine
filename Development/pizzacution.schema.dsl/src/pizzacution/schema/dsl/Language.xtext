// automatically generated by Xtext
grammar pizzacution.schema.dsl.Language with org.eclipse.xtext.common.Terminals

import "http://www.example.org/schema" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

PizzaPlace: "We" "are" name=STRING "," "and" "we" "are" "located" "at" address=STRING "."
	"We" "offer" "following" "sizes:" sizesAvailable+=SizeInfo ("," sizesAvailable+=SizeInfo)* "."
	"We" "have" "following" "toppings:" toppingsAvailable+=Topping ("," toppingsAvailable+=Topping)* "."
	"We" "offer" "the" "following" "pizzas:" pizzasAvailable+=Pizza ("," pizzasAvailable+=Pizza)* "."
;

SizeInfo returns SizeInfo: size=Sizes "that" "serves" serves=INT "people";

Pizza returns Pizza: sizeReference+=SizeInfoReference name=STRING "pizza"
	"on" dough=DoughTypes "dough"
	"with" sauce=Sauces "sauce"
	"with" toppings+=[Topping]
;

SizeInfoReference: sizeInfo=[SizeInfo];

Topping returns Topping: name=STRING;

// Notes:
// 1. Maybe we could make a central storage of dough types and sauces and so on, to which pizza place could add?
// Then we could easily extend the enums 
// 2. How do we generate the pizza in a couple of different sizes? Like let's say I declred a pizza that is "in all sizes" and then 
// multiply that somehow -- I THINK NOT RELEVANT WITH SERVING SO MANY PEOPLE
// 3. How do I reference the SizeInfo already present in the model?
// 4. How to make regex identifiers?
// 5. What is a containment reference?

//PizzaPlace returns PizzaPlace:
//	{PizzaPlace}
//	'PizzaPlace'
//	name=EString
//	'{'
//		('address' address=EString)?
//		('pizzasAvailable' '{' pizzasAvailable+=Pizza ( "," pizzasAvailable+=Pizza)* '}' )?
//	'}';
//
//
//
//EString returns ecore::EString:
//	STRING | ID;
//
//Pizza returns Pizza:
//	(hasLactose?='hasLactose')?
//	(isVegetarian?='isVegetarian')?
//	(isVegan?='isVegan')?
//	'Pizza'
//	name=EString
//	'{'
//		('calories' calories=EInt)?
//		('carbohydrates' carbohydrates=EFloat)?
//		('proteins' proteins=EFloat)?
//		('fat' fat=EFloat)?
//		('price' price=EInt)?
//		('size' size=Sizes)?
//		('sauce' sauce=Sauces)?
//		('dough' dough=DoughTypes)?
//		('toppings' '(' toppings+=[Topping|EString] ( "," toppings+=[Topping|EString])* ')' )?
//		'soldIn' '(' soldIn+=[PizzaPlace|EString] ( "," soldIn+=[PizzaPlace|EString])* ')' 
//	'}';
//
//EInt returns ecore::EInt:
//	'-'? INT;
//
//EFloat returns ecore::EFloat:
//	'-'? INT? '.' INT (('E'|'e') '-'? INT)?;
//
//EBoolean returns ecore::EBoolean:
//	'true' | 'false';
//
//Topping returns Topping:
//	{Topping}
//	(hasLactose?='hasLactose')?
//	(isVegetarian?='isVegetarian')?
//	(isVegan?='isVegan')?
//	'Topping'
//	name=EString
//	'{'
//		('calories' calories=EInt)?
//		('carbohydrates' carbohydrates=EFloat)?
//		('proteins' proteins=EFloat)?
//		('fat' fat=EFloat)?
//		('foodGroup' foodGroup=FoodGroup)?
//		('toppingAmount' toppingAmount=ToppingAmount)?
//		('pizza' '(' pizza+=[Pizza|EString] ( "," pizza+=[Pizza|EString])* ')' )?
//	'}';
//
enum Sizes returns Sizes:
				Small =  'Small' | Medium = 'Medium' | Large = 'Large' | ExtraLarge = 'XL';

enum Sauces returns Sauces:
				BBQ = 'BBQ' | Tomato = 'Tomato' | Garlic = 'Garlic';

enum DoughTypes returns DoughTypes:
				NewHavenStyle = 'New Haven Style' | StLouisStyle = 'St. Louis Style' | Neapolitan = 'Neapolitan' | NewYorkStyle = 'New York Style';
//
//enum FoodGroup returns FoodGroup:
//				vegetables = 'vegetables' | meats = 'meats' | chseeses = 'chseeses';
//
//enum ToppingAmount returns ToppingAmount:
//				small = 'small' | normal = 'normal' | large = 'large';
//