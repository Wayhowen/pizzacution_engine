// automatically generated by Xtext
grammar pizzacution.query.dsl.QueryLanguage with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.example.org/query" as query
//import "http://www.example.org/schema" as schema
// TODO: fix some problems with imports


// TODO: we need to enfore that all that clauses are different
SelectQuery returns query::SelectQuery: "I" "want" whatClause=WhatClause
	thatClause+=ThatClause ("and" thatClause+=ThatClause)
;

WhatClause returns query::WhatClause: AllPizzas | SomePizzas;

AllPizzas returns query::AllPizzas: "all" "pizzas" {query::AllPizzas};

SomePizzas returns query::SomePizza: "a" "pizza" {query::SomePizza};

// TODO: we need to enforce statically, that two of the rules has to be different
ThatClause returns query::ThatClause: "that" thatDirective=ThatDirective;

// TODO: in the future we could add boolean logic here 
ThatDirective returns query::ThatDirective: 
		(containsClause+=ContainsClause ("and" containsClause+=ContainsClause)?) |
		(costClause=CostClause) |
		(isServedClause=IsServedClause)
;

ContainsClause returns query::ContainsClause: HasClause | DoesntHaveClause;

HasClause returns query::HasClause: "has" ;

DoesntHaveClause returns query::DoesntHaveClause: "does" "not" "have" ;

CostClause returns query::CostClause: "costs" costDirective+=CostDirective ("and" costDirective+=CostDirective)?;

CostDirective returns query::CostDirective: operator=ComparativeOperator price=FLOAT;

IsServedClause returns query::IsServedClause: "is" "served" isServedDirective+=IsServedDirective ("," isServedDirective+=IsServedDirective)?;

// TODO: ensure that both directives are different
IsServedDirective returns query::IsServedDirective: InClause | AtClause;

// TODO: add referencing once fixed
AtClause returns query::AtClause: "at" pizzaPlaceReference+=PizzaPlaceReference ("," pizzaPlaceReference+=PizzaPlaceReference)?;

PizzaPlaceReference returns query::PizzaPlaceReference: {query::PizzaPlaceReference};

// TODO: add referencing once fixed
InClause returns query::InClause: "in" sizeInfoReference+=SizeInfoReference ("," sizeInfoReference+=SizeInfoReference)?;

SizeInfoReference returns query::SizeInfoReference: {query::SizeInfoReference};

//toppingReference+=ToppingReference ("," toppingReference+=ToppingReference)*

//ToppingReference returns query::ToppingReference: topping=[schema::Topping];

// TODO: why doesnt referencing work? 
// TODO: can I somehow reference pizzas by not only name but also sauce/dough without having them as separate models?

enum ComparativeOperator returns query::ComparativeOperator:
	LESS_THAN = "<" | LESS_THAN_EQUAL = "<=" | EQUAL = "=" | NOT_EQUAL = "!=" | GREATER_THAN = ">" | GREATER_THAN_OR_EQUAL = ">="
;

FLOAT returns ecore::EFloat: INT '.' INT;